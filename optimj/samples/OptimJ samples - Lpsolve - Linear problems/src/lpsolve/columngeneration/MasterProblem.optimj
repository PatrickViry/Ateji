/****************************
 * Copyright (c) 2009 ATEJI *
 * All rights reserved.     *
 ****************************/
package lpsolve.columngeneration;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import static com.ateji.monoid.Monoids.*;

// Master problem is used two times:
//  - As a linear problem in the column generation algorithm
//  - As an MIP problem to solve the original problem.
// 
// Indeed,  column generation algorithm may generate solutions that contain fractions,
// e.g. a pattern should be produced 3.5 times. This limitation is overcome by solving the master problem see
// as a MIP problem.
/**
 * The master problem is the original problem with only a subset of variables being 
 * considered.
 */
public model MasterProblem  extends MasterProblemParam solver lpsolve {
	
	
	/** use.get(p) is the number of times that pattern p is used.*/ 
	final private Map<Pattern, var double> use = new HashMap<Pattern, var double>(); 
	public Map<Pattern, var double> getUse(){return use;}	
	
	/** integerVariables represent the map use in the MIP version of the model*/ 
	final private Map<Pattern, var int> integerVariables = new HashMap<Pattern, var int>(); 
	public Map<Pattern, var int> getIntegerVariables(){return integerVariables;}	
	
    // How are you going to cut the rolls so that you minimize the cost? 
	// minimize sum{Pattern p : patterns}{p.cost*(MIPProblem?integerVariables.get(p):use.get(p))};
	
    // How are you going to minimize the number of rolls? 
	minimize sum{Pattern p : patterns}{(MIPProblem?integerVariables.get(p):use.get(p))};
	
	constraints[Order] ctFill[orders]; 
	
	// Different customers order different numbers of rolls 
	constraints {
		forall (Order o : orders){		
			ctFill[o]: sum{Pattern p : patterns}{p.fill[o]*(MIPProblem?integerVariables.get(p):use.get(p))} >= o.quantity;
		}
	}	
	
	/**
	 * Master problem is solved until no more patterns can be generated which will reduce the number of rolls cut. 
	 */
	// A new pattern may improve the solution if:
	// - No pattern was generated
	// - The objective value decreases strictly (the problem is a minimization problem).
	private double lastObjValue = Double.MAX_VALUE;
	private boolean firstCall = true;
	public boolean isProgress() {
		if (firstCall) {
			firstCall = false;
			return true;
		}
		boolean res = objValue() < lastObjValue;
		lastObjValue = objValue();
		return res;
	}
	
	public double[Order] getDuals() {
		double[Order] res[Order o : orders] = sensitivity(ctFill[o]);
		return res;
	}
	
	
	public void addPattern(Pattern p) {
		patterns.add(p);
		use.put(p, new var double(0, 10000));
	}
	
	
	/**
	 * Linear case. 
	 * 
	 * Pattern are add one by one by the column generation algorithm.
	 */
	public MasterProblem(int rollWidth, Set<Order> orders) 	{
		super(rollWidth, orders, false, null);
		for(Pattern pattern : patterns) {
			addPattern(pattern);
		}
	}
	
	/**
	 * MIP case.
	 * 
	 * Patterns have been generated by the column generation algorithm.
	 */
	public MasterProblem(int rollWidth, Set<Order> orders, Set<Pattern> patterns) 	{
		super(rollWidth, orders, true, patterns);
		for (Pattern p : patterns) {
			integerVariables.put(p, new var int(0, 10000));
		}
	}
}

class MasterProblemParam {
	
	 /** A paper mill has a number of rolls of paper of fixed width */
	final int rollWidth;
    /** Customers order different numbers of rolls of various-sized widths*/
	final Set<Order> orders;
	/** Patterns that may be use to cut the rolls */
	final Set<Pattern> patterns;
	public Set<Pattern> getPatterns(){return patterns;}
	
	/** true iff the master is seen as an MIP problem*/
	final boolean MIPProblem;
	
	public MasterProblemParam(
			int rollWidth,
			Set<Order> orders,
			boolean MIPProblem,
			Set<Pattern> patterns
	)
	{
		this.rollWidth = rollWidth;
		this.orders = orders;		
		this.patterns = MIPProblem?patterns:initialPatterns(orders); 
		this.MIPProblem = MIPProblem;
	}
	
//	 The simplest option to initialize the master problem is is to include one pattern for each order width.
	private Set<Pattern> initialPatterns(Set<Order> orders) {
		Set<Pattern> res = new HashSet<Pattern>();
		for (Order o : orders){
			int[Order] fill [Order o1 : orders] = (o == o1)?1:0;
			res.add(new Pattern(rollWidth - o.width, fill));
		}
		return res;
	}
	
}
